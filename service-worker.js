import{a0 as f,a1 as k,a2 as y,a3 as v,a4 as b,_ as S,a5 as I,Y as W,Z as E,X as C,S as x,$ as M}from"./index.js";var i=null;typeof WebSocket<"u"?i=WebSocket:typeof MozWebSocket<"u"?i=MozWebSocket:typeof global<"u"?i=global.WebSocket||global.MozWebSocket:typeof window<"u"?i=window.WebSocket||window.MozWebSocket:typeof self<"u"&&(i=self.WebSocket||self.MozWebSocket);const h=i,P="1",d=f("WebsocketClient");class T extends b{socket}class u extends T{timerId;remotePeerId;#e=!1;url;constructor(t){super(),this.url=t}connect(t){this.socket&&(this.socket.removeEventListener("open",this.onOpen),this.socket.removeEventListener("close",this.onClose),this.socket.removeEventListener("message",this.onMessage)),this.timerId||(this.timerId=setInterval(()=>this.connect(t),5e3)),this.peerId=t,this.socket=new h(this.url),this.socket.binaryType="arraybuffer",this.socket.addEventListener("open",this.onOpen),this.socket.addEventListener("close",this.onClose),this.socket.addEventListener("message",this.onMessage),setTimeout(()=>{this.#e||(this.#e=!0,this.emit("ready",{network:this}))},1e3),this.join()}onOpen=()=>{d(`@ ${this.url}: open`),clearInterval(this.timerId),this.timerId=void 0,this.send(p(this.peerId))};onClose=()=>{d(`${this.url}: close`),this.remotePeerId&&this.emit("peer-disconnected",{peerId:this.remotePeerId}),this.timerId||this.peerId&&this.connect(this.peerId)};onMessage=t=>{this.receiveMessage(t.data)};join(){if(!this.socket)throw new Error("WTF, get a socket");this.socket.readyState===h.OPEN&&this.send(p(this.peerId))}disconnect(){if(!this.socket)throw new Error("WTF, get a socket");this.send({type:"leave",senderId:this.peerId})}send(t){if("data"in t&&t.data.byteLength===0)throw new Error("tried to send a zero-length message");if(!this.peerId)throw new Error("Why don't we have a PeerID?");if(!this.socket||this.socket.readyState!==h.OPEN)throw new Error("Websocket Socket not ready!");const s=k(t),o=s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength);this.socket?.send(o)}announceConnection(t){if(!this.peerId)throw new Error("we should have a peer ID by now");this.#e||(this.#e=!0,this.emit("ready",{network:this})),this.remotePeerId=t,this.emit("peer-candidate",{peerId:t})}receiveMessage(t){const s=y(new Uint8Array(t)),{type:o,senderId:n}=s;if(!this.socket)throw new Error("Missing socket at receiveMessage");if(t.byteLength===0)throw new Error("received a zero-length message");switch(o){case"peer":d(`peer: ${n}`),this.announceConnection(n);break;case"error":d(`error: ${s.message}`);break;default:if(!v(s))throw new Error("Invalid message received");this.emit("message",s)}}}function p(e){return{type:"join",senderId:e,supportedProtocolVersions:[P]}}f("WebsocketServer");const g="v2",A=["./","./automerge_wasm_bg.wasm","./es-module-shims.js","./favicon.ico","./index.html","./index.js","./main.js","./src/vendor/automerge-wasm/web/automerge_wasm_bg.js","./src/vendor/automerge-wasm/web/automerge_wasm_bg.wasm","./src/vendor/automerge-wasm/web/automerge_wasm.js","./src/vendor/automerge-wasm/web/index.js","./src/vendor/automerge-wasm/package.json","./logos/logo-favicon-16x16.png","./logos/logo-favicon-32x32.png","./logos/logo-favicon-64x64.png","./logos/logo-favicon-96x96.png","./logos/logo-favicon-128x128.png","./logos/logo-favicon-192x192.png","./logos/logo-favicon-196x196.png","./logos/logo-favicon-310x310-transparent.png","./logos/logo-favicon-apple-touch.png","./logos/logo-lockup.svg"];async function R(){console.log("Creating repo");const e=new W({storage:new E,network:[new u("wss://sync.automerge.org")],peerId:"service-worker-"+Math.round(Math.random()*1e6),sharePolicy:async t=>t.includes("storage-server")});return await C,x(M),e}console.log("Before registration");const l=R();self.repo=l;self.addEventListener("install",e=>{console.log("Installing SW"),e.waitUntil(Promise.all([caches.open(g).then(async t=>{for(let s of A)try{console.log("sw: cache.add",s);const o=await t.add(s)}catch(o){console.warn("sw: cache.add",o)}})]).then(()=>self.skipWaiting()))});self.addEventListener("message",async e=>{if(console.log("Client messaged",e.data),e.data&&e.data.type==="INIT_PORT"){const t=e.ports[0];(await l).networkSubsystem.addNetworkAdapter(new S(t,{useWeakRef:!0}))}});function L(e){l.then(t=>t.networkSubsystem.addNetworkAdapter(new u(e)))}self.addSyncServer=L;async function j(){const e=[g],s=(await caches.keys()).map(o=>{if(!e.includes(o))return caches.delete(o)});await Promise.all(s)}self.addEventListener("activate",async e=>{console.log("Activating service worker."),await j(),clients.claim()});self.addEventListener("fetch",async e=>{const s=new URL(e.request.url).pathname.match(new RegExp("^.*/automerge-repo/(automerge:.*)"));s?e.respondWith((async()=>{let[o,...n]=s[1].split("/");if(!I(o))return new Response(`Invalid Automerge URL
${o}`,{status:500,headers:{"Content-Type":"text/plain"}});const a=(await l).find(o);await a.whenReady();const c=await a.doc();if(!c)return new Response(`Document unavailable.
${o}: ${a.state}`,{status:500,headers:{"Content-Type":"text/plain"}});if(n[0]==="package.json")return new Response(JSON.stringify(c));const r=n.reduce((w,m)=>w?.[m],c);return r?r.contentType?new Response(r.contents,{headers:{"Content-Type":r.contentType}}):typeof r=="string"?new Response(r,{headers:{"Content-Type":"text/plain"}}):new Response(JSON.stringify(r),{headers:{"Content-Type":"application/json"}}):new Response(`Not found
Object path: ${n}
${JSON.stringify(c,null,2)}`,{status:404,headers:{"Content-Type":"text/plain"}})})()):e.respondWith((async()=>{const o=await caches.match(e.request);if(console.log(`[Service Worker] Fetching resource from cache: ${e.request.url}`),o)return o;const n=await fetch(e.request),a=await caches.open(g);return console.log(`[Service Worker] Caching new resource: ${e.request.url}`),a.put(e.request,n.clone()),n})())});
