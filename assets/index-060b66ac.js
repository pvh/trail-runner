import{g as Wt}from"./_commonjsHelpers-de833af9.js";import{l as xe}from"./index-81878805.js";import{a as Pe,b as Ut,c as Ht,l as Ae,r as oe,d as Pt,e as Vt,f as zt,g as St,h as qt,i as Kt}from"./index-2253a072.js";import{s as Gt}from"./bootstrap-importmap-c375e67f.js";function Jt(e,t){for(var s=0;s<t.length;s++){const n=t[s];if(typeof n!="string"&&!Array.isArray(n)){for(const r in n)if(r!=="default"&&!(r in e)){const a=Object.getOwnPropertyDescriptor(n,r);a&&Object.defineProperty(e,r,a.get?a:{enumerable:!0,get:()=>n[r]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}var Ze={},Fe={},Be={};Object.defineProperty(Be,"__esModule",{value:!0});Be.default=void 0;var Xt=xe;var Qt=(0,Xt.declare)((e,t)=>{e.assertVersion(7);const{disallowAmbiguousJSXLike:s,dts:n}=t;var{isTSX:r}=t;return{name:"syntax-typescript",manipulateOptions(a,c){{const{plugins:o}=c;Lt(o,"flow"),Lt(o,"jsx"),o.push("objectRestSpread","classProperties"),r&&o.push("jsx")}c.plugins.push(["typescript",{disallowAmbiguousJSXLike:s,dts:n}])}}});Be.default=Qt;var Nt={},de={},ce={},Ye={};(function(e){Object.defineProperty(e,"__esModule",{value:!0});var t=Pe();function s(g){if(g&&g.__esModule)return g;var j=Object.create(null);return g&&Object.keys(g).forEach(function(w){if(w!=="default"){var S=Object.getOwnPropertyDescriptor(g,w);Object.defineProperty(j,w,S.get?S:{enumerable:!0,get:function(){return g[w]}})}}),j.default=g,Object.freeze(j)}var n=s(t);function r(g){const j=g,{node:w,parentPath:S}=j;if(S.isLogicalExpression()){const{operator:P,right:L}=S.node;if(P==="&&"||P==="||"||P==="??"&&w===L)return r(S)}if(S.isSequenceExpression()){const{expressions:P}=S.node;return P[P.length-1]===w?r(S):!0}return S.isConditional({test:w})||S.isUnaryExpression({operator:"!"})||S.isLoop({test:w})}const{LOGICAL_OPERATORS:a,arrowFunctionExpression:c,assignmentExpression:o,binaryExpression:l,booleanLiteral:p,callExpression:y,cloneNode:f,conditionalExpression:b,identifier:I,isMemberExpression:F,isOptionalCallExpression:i,isOptionalMemberExpression:u,isUpdateExpression:v,logicalExpression:_,memberExpression:$,nullLiteral:m,optionalCallExpression:E,optionalMemberExpression:N,sequenceExpression:h,updateExpression:C}=n;class x{constructor(){this._map=void 0,this._map=new WeakMap}has(j){return this._map.has(j)}get(j){if(!this.has(j))return;const w=this._map.get(j),{value:S}=w;return w.count--,w.count===0?o("=",S,j):S}set(j,w,S){return this._map.set(j,{count:S,value:w})}}function O(g,j){const{node:w}=g;if(u(w))return $(j,w.property,w.computed);if(g.isOptionalCallExpression()){const S=g.get("callee");if(g.node.optional&&S.isOptionalMemberExpression()){const P=S.node.object,L=g.scope.maybeGenerateMemoised(P);return S.get("object").replaceWith(o("=",L,P)),y($(j,I("call")),[L,...g.node.arguments])}return y(j,g.node.arguments)}return g.node}function M(g){for(;g&&!g.isProgram();){const{parentPath:j,container:w,listKey:S}=g,P=j.node;if(S){if(w!==P[S])return!0}else if(w!==P)return!0;g=j}return!1}const U={memoise(){},handle(g,j){const{node:w,parent:S,parentPath:P,scope:L}=g;if(g.isOptionalMemberExpression()){if(M(g))return;const B=g.find(({node:R,parent:Y})=>u(Y)?Y.optional||Y.object!==R:i(Y)?R!==g.node&&Y.optional||Y.callee!==R:!0);if(L.path.isPattern()){B.replaceWith(y(c([],B.node),[]));return}const q=r(B),V=B.parentPath;if(V.isUpdateExpression({argument:w})||V.isAssignmentExpression({left:w}))throw g.buildCodeFrameError("can't handle assignment");const G=V.isUnaryExpression({operator:"delete"});if(G&&B.isOptionalMemberExpression()&&B.get("property").isPrivateName())throw g.buildCodeFrameError("can't delete a private class element");let A=g;for(;;){if(A.isOptionalMemberExpression()){if(A.node.optional)break;A=A.get("object");continue}else if(A.isOptionalCallExpression()){if(A.node.optional)break;A=A.get("callee");continue}throw new Error(`Internal error: unexpected ${A.node.type}`)}const ee=A.isOptionalMemberExpression()?A.node.object:A.node.callee,re=L.maybeGenerateMemoised(ee),se=re??ee,be=P.isOptionalCallExpression({callee:w}),D=R=>be,K=P.isCallExpression({callee:w});A.replaceWith(O(A,se)),D()?S.optional?P.replaceWith(this.optionalCall(g,S.arguments)):P.replaceWith(this.call(g,S.arguments)):K?g.replaceWith(this.boundGet(g)):this.delete&&P.isUnaryExpression({operator:"delete"})?P.replaceWith(this.delete(g)):g.replaceWith(this.get(g));let W=g.node;for(let R=g;R!==B;){const Y=R.parentPath;if(Y===B&&D()&&S.optional){W=Y.node;break}W=O(Y,W),R=Y}let Z;const he=B.parentPath;if(F(W)&&he.isOptionalCallExpression({callee:B.node,optional:!0})){const{object:R}=W;Z=g.scope.maybeGenerateMemoised(R),Z&&(W.object=o("=",Z,R))}let Ve=B;G&&(Ve=he,W=he.node);const Ie=re?o("=",f(se),f(ee)):f(se);if(q){let R;j?R=l("!=",Ie,m()):R=_("&&",l("!==",Ie,m()),l("!==",f(se),L.buildUndefinedNode())),Ve.replaceWith(_("&&",R,W))}else{let R;j?R=l("==",Ie,m()):R=_("||",l("===",Ie,m()),l("===",f(se),L.buildUndefinedNode())),Ve.replaceWith(b(R,G?p(!0):L.buildUndefinedNode(),W))}if(Z){const R=he.node;he.replaceWith(E(N(R.callee,I("call"),!1,!0),[f(Z),...R.arguments],!1))}return}if(v(S,{argument:w})){if(this.simpleSet){g.replaceWith(this.simpleSet(g));return}const{operator:B,prefix:q}=S;this.memoise(g,2);const V=L.generateUidIdentifierBasedOnNode(w);L.push({id:V});const G=[o("=",f(V),this.get(g))];if(q){G.push(C(B,f(V),q));const A=h(G);P.replaceWith(this.set(g,A));return}else{const A=L.generateUidIdentifierBasedOnNode(w);L.push({id:A}),G.push(o("=",f(A),C(B,f(V),q)),f(V));const ee=h(G);P.replaceWith(h([this.set(g,ee),f(A)]));return}}if(P.isAssignmentExpression({left:w})){if(this.simpleSet){g.replaceWith(this.simpleSet(g));return}const{operator:B,right:q}=P.node;if(B==="=")P.replaceWith(this.set(g,q));else{const V=B.slice(0,-1);a.includes(V)?(this.memoise(g,1),P.replaceWith(_(V,this.get(g),this.set(g,q)))):(this.memoise(g,2),P.replaceWith(this.set(g,l(V,this.get(g),q))))}return}if(P.isCallExpression({callee:w})){P.replaceWith(this.call(g,P.node.arguments));return}if(P.isOptionalCallExpression({callee:w})){if(L.path.isPattern()){P.replaceWith(y(c([],P.node),[]));return}P.replaceWith(this.optionalCall(g,P.node.arguments));return}if(this.delete&&P.isUnaryExpression({operator:"delete"})){P.replaceWith(this.delete(g));return}if(P.isForXStatement({left:w})||P.isObjectProperty({value:w})&&P.parentPath.isObjectPattern()||P.isAssignmentPattern({left:w})&&P.parentPath.isObjectProperty({value:S})&&P.parentPath.parentPath.isObjectPattern()||P.isArrayPattern()||P.isAssignmentPattern({left:w})&&P.parentPath.isArrayPattern()||P.isRestElement()){g.replaceWith(this.destructureSet(g));return}P.isTaggedTemplateExpression()?g.replaceWith(this.boundGet(g)):g.replaceWith(this.get(g))}};function ie(g,j,w){g.traverse(j,Object.assign({},U,w,{memoiser:new x}))}e.default=ie})(Ye);var Re={};Object.defineProperty(Re,"__esModule",{value:!0});Re.default=ts;var Zt=Pe();const{callExpression:rt,identifier:we,isIdentifier:Yt,isSpreadElement:es,memberExpression:ot,optionalCallExpression:at,optionalMemberExpression:lt}=Zt;function ts(e,t,s,n){return s.length===1&&es(s[0])&&Yt(s[0].argument,{name:"arguments"})?n?at(lt(e,we("apply"),!1,!0),[t,s[0].argument],!1):rt(ot(e,we("apply")),[t,s[0].argument]):n?at(lt(e,we("call"),!1,!0),[t,...s],!1):rt(ot(e,we("call")),[t,...s])}Object.defineProperty(ce,"__esModule",{value:!0});ce.default=void 0;var It=Ae,ss=Ye,De=Re,ct=Ut(),wt=Ht(),ns=Pe();const{assignmentExpression:_t,booleanLiteral:is,callExpression:Oe,cloneNode:Q,identifier:ve,memberExpression:fe,sequenceExpression:ze,stringLiteral:rs,thisExpression:me}=ns;{const e=Ae;ce.environmentVisitor=e.default,ce.skipAllButComputedKey=e.skipAllButComputedKey}function dt(e,t,s,n){e=Q(e);const r=t||n?e:fe(e,ve("prototype"));return Oe(s.addHelper("getPrototypeOf"),[r])}const os=wt.default.visitors.merge([It.default,{Super(e,t){const{node:s,parentPath:n}=e;n.isMemberExpression({object:s})&&t.handle(n)}}]),as=wt.default.visitors.merge([It.default,{Scopable(e,{refName:t}){const s=e.scope.getOwnBinding(t);s&&s.identifier.name===t&&e.scope.rename(t)}}]),Ct={memoise(e,t){const{scope:s,node:n}=e,{computed:r,property:a}=n;if(!r)return;const c=s.maybeGenerateMemoised(a);c&&this.memoiser.set(a,c,t)},prop(e){const{computed:t,property:s}=e.node;return this.memoiser.has(s)?Q(this.memoiser.get(s)):t?Q(s):rs(s.name)},get(e){return this._get(e,this._getThisRefs())},_get(e,t){const s=dt(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return Oe(this.file.addHelper("get"),[t.memo?ze([t.memo,s]):s,this.prop(e),t.this])},_getThisRefs(){if(!this.isDerivedConstructor)return{this:me()};const e=this.scope.generateDeclaredUidIdentifier("thisSuper");return{memo:_t("=",e,me()),this:Q(e)}},set(e,t){const s=this._getThisRefs(),n=dt(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return Oe(this.file.addHelper("set"),[s.memo?ze([s.memo,n]):n,this.prop(e),t,s.this,is(e.isInStrictMode())])},destructureSet(e){throw e.buildCodeFrameError("Destructuring to a super field is not supported yet.")},call(e,t){const s=this._getThisRefs();return(0,De.default)(this._get(e,s),Q(s.this),t,!1)},optionalCall(e,t){const s=this._getThisRefs();return(0,De.default)(this._get(e,s),Q(s.this),t,!0)},delete(e){return e.node.computed?ze([Oe(this.file.addHelper("toPropertyKey"),[Q(e.node.property)]),ct.default.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]):ct.default.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `}},ls=Object.assign({},Ct,{prop(e){const{property:t}=e.node;return this.memoiser.has(t)?Q(this.memoiser.get(t)):Q(t)},get(e){const{isStatic:t,getSuperRef:s}=this,{computed:n}=e.node,r=this.prop(e);let a;if(t){var c;a=(c=s())!=null?c:fe(ve("Function"),ve("prototype"))}else{var o;a=fe((o=s())!=null?o:ve("Object"),ve("prototype"))}return fe(a,r,n)},set(e,t){const{computed:s}=e.node,n=this.prop(e);return _t("=",fe(me(),n,s),t)},destructureSet(e){const{computed:t}=e.node,s=this.prop(e);return fe(me(),s,t)},call(e,t){return(0,De.default)(this.get(e),me(),t,!1)},optionalCall(e,t){return(0,De.default)(this.get(e),me(),t,!0)}});class cs{constructor(t){var s;const n=t.methodPath;this.methodPath=n,this.isDerivedConstructor=n.isClassMethod({kind:"constructor"})&&!!t.superRef,this.isStatic=n.isObjectMethod()||n.node.static||(n.isStaticBlock==null?void 0:n.isStaticBlock()),this.isPrivateMethod=n.isPrivate()&&n.isMethod(),this.file=t.file,this.constantSuper=(s=t.constantSuper)!=null?s:t.isLoose,this.opts=t}getObjectRef(){return Q(this.opts.objectRef||this.opts.getObjectRef())}getSuperRef(){if(this.opts.superRef)return Q(this.opts.superRef);if(this.opts.getSuperRef)return Q(this.opts.getSuperRef())}replace(){this.opts.refToPreserve&&this.methodPath.traverse(as,{refName:this.opts.refToPreserve.name});const t=this.constantSuper?ls:Ct;(0,ss.default)(this.methodPath,os,Object.assign({file:this.file,scope:this.methodPath.scope,isDerivedConstructor:this.isDerivedConstructor,isStatic:this.isStatic,isPrivateMethod:this.isPrivateMethod,getObjectRef:this.getObjectRef.bind(this),getSuperRef:this.getSuperRef.bind(this),boundGet:t.get},t))}}ce.default=cs;var Le={};Object.defineProperty(Le,"__esModule",{value:!0});Le.default=ms;var ds=Pe();const{addComment:us}=ds,ps="#__PURE__",fs=({leadingComments:e})=>!!e&&e.some(t=>/[@#]__PURE__/.test(t.value));function ms(e){const t=e.node||e;fs(t)||us(t,"leading",ps)}var Se={};Object.defineProperty(Se,"__esModule",{value:!0});Se.isTransparentExprWrapper=et;Se.skipTransparentExprWrapperNodes=Ss;Se.skipTransparentExprWrappers=Ps;var ys=Pe();const{isParenthesizedExpression:gs,isTSAsExpression:bs,isTSNonNullExpression:hs,isTSSatisfiesExpression:vs,isTSTypeAssertion:Es,isTypeCastExpression:xs}=ys;function et(e){return bs(e)||vs(e)||Es(e)||hs(e)||xs(e)||gs(e)}function Ps(e){for(;et(e.node);)e=e.get("expression");return e}function Ss(e){for(;et(e);)e=e.expression;return e}var We={};Object.defineProperty(We,"__esModule",{value:!0});We.assertFieldTransformed=Ns;function Ns(e){if(e.node.declare)throw e.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:
 - @babel/plugin-transform-class-properties
 - @babel/plugin-transform-private-methods
 - @babel/plugin-proposal-decorators`)}Object.defineProperty(de,"__esModule",{value:!0});de.buildCheckInRHS=je;de.buildFieldsInitNodes=Ks;de.buildPrivateNamesMap=Ts;de.buildPrivateNamesNodes=Os;de.transformPrivateNamesUsage=As;var d=oe(),Is=ce,$t=Ae,ws=Ye,ut=Re,_s=Le,Cs=Se,$s=We;function Ts(e){const t=new Map;for(const s of e)if(s.isPrivate()){const{name:n}=s.node.key.id,r=t.has(n)?t.get(n):{id:s.scope.generateUidIdentifier(n),static:s.node.static,method:!s.isProperty()};s.isClassPrivateMethod()&&(s.node.kind==="get"?r.getId=s.scope.generateUidIdentifier(`get_${n}`):s.node.kind==="set"?r.setId=s.scope.generateUidIdentifier(`set_${n}`):s.node.kind==="method"&&(r.methodId=s.scope.generateUidIdentifier(n))),t.set(n,r)}return t}function Os(e,t,s,n){const r=[];for(const[a,c]of e){const{static:o,method:l,getId:p,setId:y}=c,f=p||y,b=d.types.cloneNode(c.id);let I;t?I=d.types.callExpression(n.addHelper("classPrivateFieldLooseKey"),[d.types.stringLiteral(a)]):s?I=d.types.callExpression(d.types.identifier("Symbol"),[d.types.stringLiteral(a)]):o||(I=d.types.newExpression(d.types.identifier(!l||f?"WeakMap":"WeakSet"),[])),I&&((0,_s.default)(I),r.push(d.template.statement.ast`var ${b} = ${I}`))}return r}function Tt(e){const t=d.traverse.visitors.merge([Object.assign({},e),$t.default]),s=Object.assign({},e,{Class(n){const{privateNamesMap:r}=this,a=n.get("body.body"),c=new Map(r),o=[];for(const l of a){if(!l.isPrivate())continue;const{name:p}=l.node.key.id;c.delete(p),o.push(p)}o.length&&(n.get("body").traverse(t,Object.assign({},this,{redeclared:o})),n.traverse(s,Object.assign({},this,{privateNamesMap:c})),n.skipKey("body"))}});return s}const js=Tt({PrivateName(e,{noDocumentAll:t}){const{privateNamesMap:s,redeclared:n}=this,{node:r,parentPath:a}=e;if(!a.isMemberExpression({property:r})&&!a.isOptionalMemberExpression({property:r}))return;const{name:c}=r.id;s.has(c)&&(n&&n.includes(c)||this.handle(a,t))}});function Ot(e,t,s){for(;(n=t)!=null&&n.hasBinding(e)&&!t.bindingIdentifierEquals(e,s);){var n;t.rename(e),t=t.parent}}function je(e,t,s){return s||!(t.availableHelper!=null&&t.availableHelper("checkInRHS"))?e:d.types.callExpression(t.addHelper("checkInRHS"),[e])}const Ds=Tt({BinaryExpression(e,{file:t}){const{operator:s,left:n,right:r}=e.node;if(s!=="in"||!d.types.isPrivateName(n))return;const{privateFieldsAsProperties:a,privateNamesMap:c,redeclared:o}=this,{name:l}=n.id;if(!c.has(l)||o&&o.includes(l))return;if(Ot(this.classRef.name,e.scope,this.innerBinding),a){const{id:f}=c.get(l);e.replaceWith(d.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${je(r,t)}, ${d.types.cloneNode(f)})
      `);return}const{id:p,static:y}=c.get(l);if(y){e.replaceWith(d.template.expression.ast`${je(r,t)} === ${d.types.cloneNode(this.classRef)}`);return}e.replaceWith(d.template.expression.ast`${d.types.cloneNode(p)}.has(${je(r,t)})`)}}),ks={memoise(e,t){const{scope:s}=e,{object:n}=e.node,r=s.maybeGenerateMemoised(n);r&&this.memoiser.set(n,r,t)},receiver(e){const{object:t}=e.node;return this.memoiser.has(t)?d.types.cloneNode(this.memoiser.get(t)):d.types.cloneNode(t)},get(e){const{classRef:t,privateNamesMap:s,file:n,innerBinding:r}=this,{name:a}=e.node.property.id,{id:c,static:o,method:l,methodId:p,getId:y,setId:f}=s.get(a),b=y||f;if(o){const I=l&&!b?"classStaticPrivateMethodGet":"classStaticPrivateFieldSpecGet";return Ot(t.name,e.scope,r),d.types.callExpression(n.addHelper(I),[this.receiver(e),d.types.cloneNode(t),d.types.cloneNode(c)])}if(l){if(b){if(!y&&f){if(n.availableHelper("writeOnlyError"))return d.types.sequenceExpression([this.receiver(e),d.types.callExpression(n.addHelper("writeOnlyError"),[d.types.stringLiteral(`#${a}`)])]);console.warn("@babel/helpers is outdated, update it to silence this warning.")}return d.types.callExpression(n.addHelper("classPrivateFieldGet"),[this.receiver(e),d.types.cloneNode(c)])}return d.types.callExpression(n.addHelper("classPrivateMethodGet"),[this.receiver(e),d.types.cloneNode(c),d.types.cloneNode(p)])}return d.types.callExpression(n.addHelper("classPrivateFieldGet"),[this.receiver(e),d.types.cloneNode(c)])},boundGet(e){return this.memoise(e,1),d.types.callExpression(d.types.memberExpression(this.get(e),d.types.identifier("bind")),[this.receiver(e)])},set(e,t){const{classRef:s,privateNamesMap:n,file:r}=this,{name:a}=e.node.property.id,{id:c,static:o,method:l,setId:p,getId:y}=n.get(a),f=y||p;if(o){const b=l&&!f?"classStaticPrivateMethodSet":"classStaticPrivateFieldSpecSet";return d.types.callExpression(r.addHelper(b),[this.receiver(e),d.types.cloneNode(s),d.types.cloneNode(c),t])}return l?p?d.types.callExpression(r.addHelper("classPrivateFieldSet"),[this.receiver(e),d.types.cloneNode(c),t]):d.types.sequenceExpression([this.receiver(e),t,d.types.callExpression(r.addHelper("readOnlyError"),[d.types.stringLiteral(`#${a}`)])]):d.types.callExpression(r.addHelper("classPrivateFieldSet"),[this.receiver(e),d.types.cloneNode(c),t])},destructureSet(e){const{classRef:t,privateNamesMap:s,file:n}=this,{name:r}=e.node.property.id,{id:a,static:c}=s.get(r);if(c){try{var o=n.addHelper("classStaticPrivateFieldDestructureSet")}catch{throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.")}return d.types.memberExpression(d.types.callExpression(o,[this.receiver(e),d.types.cloneNode(t),d.types.cloneNode(a)]),d.types.identifier("value"))}return d.types.memberExpression(d.types.callExpression(n.addHelper("classPrivateFieldDestructureSet"),[this.receiver(e),d.types.cloneNode(a)]),d.types.identifier("value"))},call(e,t){return this.memoise(e,1),(0,ut.default)(this.get(e),this.receiver(e),t,!1)},optionalCall(e,t){return this.memoise(e,1),(0,ut.default)(this.get(e),this.receiver(e),t,!0)},delete(){throw new Error("Internal Babel error: deleting private elements is a parsing error.")}},Ms={get(e){const{privateNamesMap:t,file:s}=this,{object:n}=e.node,{name:r}=e.node.property.id;return d.template.expression`BASE(REF, PROP)[PROP]`({BASE:s.addHelper("classPrivateFieldLooseBase"),REF:d.types.cloneNode(n),PROP:d.types.cloneNode(t.get(r).id)})},set(){throw new Error("private name handler with loose = true don't need set()")},boundGet(e){return d.types.callExpression(d.types.memberExpression(this.get(e),d.types.identifier("bind")),[d.types.cloneNode(e.node.object)])},simpleSet(e){return this.get(e)},destructureSet(e){return this.get(e)},call(e,t){return d.types.callExpression(this.get(e),t)},optionalCall(e,t){return d.types.optionalCallExpression(this.get(e),t,!0)},delete(){throw new Error("Internal Babel error: deleting private elements is a parsing error.")}};function As(e,t,s,{privateFieldsAsProperties:n,noDocumentAll:r,innerBinding:a},c){if(!s.size)return;const o=t.get("body"),l=n?Ms:ks;(0,ws.default)(o,js,Object.assign({privateNamesMap:s,classRef:e,file:c},l,{noDocumentAll:r,innerBinding:a})),o.traverse(Ds,{privateNamesMap:s,classRef:e,file:c,privateFieldsAsProperties:n,innerBinding:a})}function pt(e,t,s){const{id:n}=s.get(t.node.key.id.name),r=t.node.value||t.scope.buildUndefinedNode();return H(d.template.statement.ast`
      Object.defineProperty(${e}, ${d.types.cloneNode(n)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${r}
      });
    `,t)}function Fs(e,t,s,n){const{id:r}=s.get(t.node.key.id.name),a=t.node.value||t.scope.buildUndefinedNode();if(!n.availableHelper("classPrivateFieldInitSpec"))return H(d.template.statement.ast`${d.types.cloneNode(r)}.set(${e}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${a},
        })`,t);const c=n.addHelper("classPrivateFieldInitSpec");return H(d.template.statement.ast`${c}(
      ${d.types.thisExpression()},
      ${d.types.cloneNode(r)},
      {
        writable: true,
        value: ${a}
      },
    )`,t)}function ft(e,t){const s=t.get(e.node.key.id.name),{id:n,getId:r,setId:a,initAdded:c}=s,o=r||a;if(!e.isProperty()&&(c||!o))return;if(o)return t.set(e.node.key.id.name,Object.assign({},s,{initAdded:!0})),H(d.template.statement.ast`
        var ${d.types.cloneNode(n)} = {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${r?r.name:e.scope.buildUndefinedNode()},
          set: ${a?a.name:e.scope.buildUndefinedNode()}
        }
      `,e);const l=e.node.value||e.scope.buildUndefinedNode();return H(d.template.statement.ast`
      var ${d.types.cloneNode(n)} = {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${l}
      };
    `,e)}function Bs(e,t,s){const n=s.get(t.node.key.id.name),{methodId:r,id:a,getId:c,setId:o,initAdded:l}=n;if(l)return;if(r)return H(d.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${r.name}
        });
      `,t);if(c||o)return s.set(t.node.key.id.name,Object.assign({},n,{initAdded:!0})),H(d.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${c?c.name:t.scope.buildUndefinedNode()},
          set: ${o?o.name:t.scope.buildUndefinedNode()}
        });
      `,t)}function Rs(e,t,s,n){const r=s.get(t.node.key.id.name),{getId:a,setId:c,initAdded:o}=r;return o?void 0:a||c?Ls(e,t,s,n):Ws(e,t,s,n)}function Ls(e,t,s,n){const r=s.get(t.node.key.id.name),{id:a,getId:c,setId:o}=r;if(s.set(t.node.key.id.name,Object.assign({},r,{initAdded:!0})),!n.availableHelper("classPrivateFieldInitSpec"))return H(d.template.statement.ast`
          ${a}.set(${e}, {
            get: ${c?c.name:t.scope.buildUndefinedNode()},
            set: ${o?o.name:t.scope.buildUndefinedNode()}
          });
        `,t);const l=n.addHelper("classPrivateFieldInitSpec");return H(d.template.statement.ast`${l}(
      ${d.types.thisExpression()},
      ${d.types.cloneNode(a)},
      {
        get: ${c?c.name:t.scope.buildUndefinedNode()},
        set: ${o?o.name:t.scope.buildUndefinedNode()}
      },
    )`,t)}function Ws(e,t,s,n){const r=s.get(t.node.key.id.name),{id:a}=r;if(!n.availableHelper("classPrivateMethodInitSpec"))return H(d.template.statement.ast`${a}.add(${e})`,t);const c=n.addHelper("classPrivateMethodInitSpec");return H(d.template.statement.ast`${c}(
      ${d.types.thisExpression()},
      ${d.types.cloneNode(a)}
    )`,t)}function mt(e,t){const{key:s,computed:n}=t.node,r=t.node.value||t.scope.buildUndefinedNode();return H(d.types.expressionStatement(d.types.assignmentExpression("=",d.types.memberExpression(e,s,n||d.types.isLiteral(s)),r)),t)}function yt(e,t,s){const{key:n,computed:r}=t.node,a=t.node.value||t.scope.buildUndefinedNode();return H(d.types.expressionStatement(d.types.callExpression(s.addHelper("defineProperty"),[e,r||d.types.isLiteral(n)?n:d.types.stringLiteral(n.name),a])),t)}function Us(e,t,s,n){const r=n.get(t.node.key.id.name),{id:a,methodId:c,getId:o,setId:l,initAdded:p}=r;return p?void 0:o||l?(n.set(t.node.key.id.name,Object.assign({},r,{initAdded:!0})),H(d.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${o?o.name:t.scope.buildUndefinedNode()},
          set: ${l?l.name:t.scope.buildUndefinedNode()}
        })
      `,t)):H(d.template.statement.ast`
      Object.defineProperty(${e}, ${a}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${c.name}
      });
    `,t)}function _e(e,t,s=!1){const n=t.get(e.node.key.id.name),{id:r,methodId:a,getId:c,setId:o,getterDeclared:l,setterDeclared:p,static:y}=n,{params:f,body:b,generator:I,async:F}=e.node,i=c&&!l&&f.length===0,u=o&&!p&&f.length>0;let v=a;return i?(t.set(e.node.key.id.name,Object.assign({},n,{getterDeclared:!0})),v=c):u?(t.set(e.node.key.id.name,Object.assign({},n,{setterDeclared:!0})),v=o):y&&!s&&(v=r),H(d.types.functionDeclaration(d.types.cloneNode(v),f,b,I,F),e)}const Hs=d.traverse.visitors.merge([{ThisExpression(e,t){const s=e.findParent(n=>!(0,Cs.isTransparentExprWrapper)(n.node));if(d.types.isUnaryExpression(s.node,{operator:"delete"})){e.parentPath.replaceWith(d.types.booleanLiteral(!0));return}t.needsClassRef=!0,e.replaceWith(d.types.cloneNode(t.classRef))},MetaProperty(e){const t=e.get("meta"),s=e.get("property"),{scope:n}=e;t.isIdentifier({name:"new"})&&s.isIdentifier({name:"target"})&&e.replaceWith(n.buildUndefinedNode())}},$t.default]),Vs={ReferencedIdentifier(e,t){e.scope.bindingIdentifierEquals(e.node.name,t.innerBinding)&&(t.needsClassRef=!0,e.node.name=t.classRef.name)}};function zs(e,t,s,n,r,a,c){var o;const l={classRef:t,needsClassRef:!1,innerBinding:c};return new Is.default({methodPath:e,constantSuper:a,file:n,refToPreserve:t,getSuperRef:s,getObjectRef(){return l.needsClassRef=!0,d.types.isStaticBlock!=null&&d.types.isStaticBlock(e.node)||e.node.static?t:d.types.memberExpression(t,d.types.identifier("prototype"))}}).replace(),(r||e.isProperty())&&e.traverse(Hs,l),c!=null&&(o=l.classRef)!=null&&o.name&&l.classRef.name!==c?.name&&e.traverse(Vs,l),l.needsClassRef}function qs({key:e,computed:t}){return e.type==="Identifier"?!t&&(e.name==="name"||e.name==="length"):e.type==="StringLiteral"?e.value==="name"||e.value==="length":!1}function H(e,t){return d.types.inheritLeadingComments(e,t.node),d.types.inheritInnerComments(e,t.node),e}function Ks(e,t,s,n,r,a,c,o,l){let p=!1,y;const f=[],b=[],I=[],F=d.types.isIdentifier(t)?()=>t:()=>{var i;return(i=y)!=null||(y=s[0].scope.generateUidIdentifierBasedOnNode(t)),y};for(const i of s){i.isClassProperty()&&$s.assertFieldTransformed(i);const u=!(d.types.isStaticBlock!=null&&d.types.isStaticBlock(i.node))&&i.node.static,v=!u,_=i.isPrivate(),$=!_,m=i.isProperty(),E=!m,N=i.isStaticBlock==null?void 0:i.isStaticBlock();if(u||E&&_||N){const h=zs(i,e,F,r,N,o,l);p=p||h}switch(!0){case N:{const h=i.node.body;h.length===1&&d.types.isExpressionStatement(h[0])?f.push(H(h[0],i)):f.push(d.types.inheritsComments(d.template.statement.ast`(() => { ${h} })()`,i.node));break}case(u&&_&&m&&c):p=!0,f.push(pt(d.types.cloneNode(e),i,n));break;case(u&&_&&m&&!c):p=!0,f.push(ft(i,n));break;case(u&&$&&m&&a):if(!qs(i.node)){p=!0,f.push(mt(d.types.cloneNode(e),i));break}case(u&&$&&m&&!a):p=!0,f.push(yt(d.types.cloneNode(e),i,r));break;case(v&&_&&m&&c):b.push(pt(d.types.thisExpression(),i,n));break;case(v&&_&&m&&!c):b.push(Fs(d.types.thisExpression(),i,n,r));break;case(v&&_&&E&&c):b.unshift(Bs(d.types.thisExpression(),i,n)),I.push(_e(i,n,c));break;case(v&&_&&E&&!c):b.unshift(Rs(d.types.thisExpression(),i,n,r)),I.push(_e(i,n,c));break;case(u&&_&&E&&!c):p=!0,f.unshift(ft(i,n)),I.push(_e(i,n,c));break;case(u&&_&&E&&c):p=!0,f.unshift(Us(d.types.cloneNode(e),i,r,n)),I.push(_e(i,n,c));break;case(v&&$&&m&&a):b.push(mt(d.types.thisExpression(),i));break;case(v&&$&&m&&!a):b.push(yt(d.types.thisExpression(),i,r));break;default:throw new Error("Unreachable.")}}return{staticNodes:f.filter(Boolean),instanceNodes:b.filter(Boolean),pureStaticNodes:I.filter(Boolean),wrapClass(i){for(const u of s)u.node.leadingComments=null,u.remove();return y&&(i.scope.push({id:d.types.cloneNode(y)}),i.set("superClass",d.types.assignmentExpression("=",y,i.node.superClass))),p&&(i.isClassExpression()?(i.scope.push({id:e}),i.replaceWith(d.types.assignmentExpression("=",d.types.cloneNode(e),i.node))):i.node.id||(i.node.id=e)),i}}}var ge={};Object.defineProperty(ge,"__esModule",{value:!0});ge.buildDecoratedClass=tn;ge.hasDecorators=Xs;ge.hasOwnDecorators=Ke;var k=oe(),Gs=ce,Js=Pt;function Ke(e){return!!(e.decorators&&e.decorators.length)}function Xs(e){return Ke(e)||e.body.body.some(Ke)}function pe(e,t){return t?k.types.objectProperty(k.types.identifier(e),t):null}function Qs(e,t){return k.types.objectMethod("method",k.types.identifier(e),[],k.types.blockStatement(t))}function jt(e){let t;return e.decorators&&e.decorators.length>0&&(t=k.types.arrayExpression(e.decorators.map(s=>s.expression))),e.decorators=void 0,t}function Zs(e){return e.computed?e.key:k.types.isIdentifier(e.key)?k.types.stringLiteral(e.key.name):k.types.stringLiteral(String(e.key.value))}function Ys(e,t,s,n){const r=n.isClassMethod();if(n.isPrivate())throw n.buildCodeFrameError(`Private ${r?"methods":"fields"} in decorated classes are not supported yet.`);if(n.node.type==="ClassAccessorProperty")throw n.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');if(n.node.type==="StaticBlock")throw n.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');const{node:a,scope:c}=n;n.isTSDeclareMethod()||new Gs.default({methodPath:n,objectRef:t,superRef:s,file:e,refToPreserve:t}).replace();const o=[pe("kind",k.types.stringLiteral(k.types.isClassMethod(a)?a.kind:"field")),pe("decorators",jt(a)),pe("static",a.static&&k.types.booleanLiteral(!0)),pe("key",Zs(a))].filter(Boolean);if(k.types.isClassMethod(a)){const l=a.computed?null:a.key,p=k.types.toExpression(a);o.push(pe("value",(0,Js.default)({node:p,id:l,scope:c})||p))}else k.types.isClassProperty(a)&&a.value?o.push(Qs("value",k.template.statements.ast`return ${a.value}`)):o.push(pe("value",c.buildUndefinedNode()));return n.remove(),k.types.objectExpression(o)}function en(e){return e.addHelper("decorate")}function tn(e,t,s,n){const{node:r,scope:a}=t,c=a.generateUidIdentifier("initialize"),o=r.id&&t.isDeclaration(),l=t.isInStrictMode(),{superClass:p}=r;r.type="ClassDeclaration",r.id||(r.id=k.types.cloneNode(e));let y;p&&(y=a.generateUidIdentifierBasedOnNode(r.superClass,"super"),r.superClass=y);const f=jt(r),b=k.types.arrayExpression(s.filter(u=>!u.node.abstract&&u.node.type!=="TSIndexSignature").map(u=>Ys(n,r.id,y,u))),I=k.template.expression.ast`
    ${en(n)}(
      ${f||k.types.nullLiteral()},
      function (${c}, ${p?k.types.cloneNode(y):null}) {
        ${r}
        return { F: ${k.types.cloneNode(r.id)}, d: ${b} };
      },
      ${p}
    )
  `;l||I.arguments[1].body.directives.push(k.types.directive(k.types.directiveLiteral("use strict")));let F=I,i="arguments.1.body.body.0";return o&&(F=k.template.statement.ast`let ${e} = ${I}`,i="declarations.0.init."+i),{instanceNodes:[k.template.statement.ast`${k.types.cloneNode(c)}(this)`],wrapClass(u){return u.replaceWith(F),u.get(i)}}}var Ue={};Object.defineProperty(Ue,"__esModule",{value:!0});Ue.extractComputedKeys=ln;Ue.injectInitialization=an;var z=oe(),sn=Ae;const nn=z.traverse.visitors.merge([{Super(e){const{node:t,parentPath:s}=e;s.isCallExpression({callee:t})&&this.push(s)}},sn.default]),rn={"TSTypeAnnotation|TypeAnnotation"(e){e.skip()},ReferencedIdentifier(e,{scope:t}){t.hasOwnBinding(e.node.name)&&(t.rename(e.node.name),e.skip())}};function Dt(e,t){if(t.classBinding&&t.classBinding===e.scope.getBinding(e.node.name)){const s=t.file.addHelper("classNameTDZError"),n=z.types.callExpression(s,[z.types.stringLiteral(e.node.name)]);e.replaceWith(z.types.sequenceExpression([n,e.node])),e.skip()}}const on={ReferencedIdentifier:Dt};function an(e,t,s,n){if(!s.length)return;const r=!!e.node.superClass;if(!t){const a=z.types.classMethod("constructor",z.types.identifier("constructor"),[],z.types.blockStatement([]));r&&(a.params=[z.types.restElement(z.types.identifier("args"))],a.body.body.push(z.template.statement.ast`super(...args)`)),[t]=e.get("body").unshiftContainer("body",a)}if(n&&n(rn,{scope:t.scope}),r){const a=[];t.traverse(nn,a);let c=!0;for(const o of a)c?(o.insertAfter(s),c=!1):o.insertAfter(s.map(l=>z.types.cloneNode(l)))}else t.get("body").unshiftContainer("body",s)}function ln(e,t,s){const n=[],r={classBinding:e.node.id&&e.scope.getBinding(e.node.id.name),file:s};for(const a of t){const c=a.get("key");c.isReferencedIdentifier()?Dt(c,r):c.traverse(on,r);const o=a.node;if(!c.isConstantExpression()){const l=e.scope.generateUidIdentifierBasedOnNode(o.key);e.scope.push({id:l,kind:"let"}),n.push(z.types.expressionStatement(z.types.assignmentExpression("=",z.types.cloneNode(l),o.key))),o.key=z.types.cloneNode(l)}}return n}var ue={};Object.defineProperty(ue,"__esModule",{value:!0});ue.FEATURES=void 0;ue.enableFeature=cn;ue.isLoose=Je;ue.shouldTransform=dn;var gt=ge;const te=Object.freeze({fields:2,privateMethods:4,decorators:8,privateIn:16,staticBlocks:32});ue.FEATURES=te;const bt=new Map([[te.fields,"@babel/plugin-transform-class-properties"],[te.privateMethods,"@babel/plugin-transform-private-methods"],[te.privateIn,"@babel/plugin-transform-private-property-in-object"]]),Ge="@babel/plugin-class-features/featuresKey",Ee="@babel/plugin-class-features/looseKey",le="@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";function cn(e,t,s){(!ne(e,t)||ht(e,t))&&(e.set(Ge,e.get(Ge)|t),s==="#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error"?(Ce(e,t,!0),e.set(le,e.get(le)|t)):s==="#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"?(Ce(e,t,!1),e.set(le,e.get(le)|t)):Ce(e,t,s));let n,r;for(const[a,c]of bt){if(!ne(e,a))continue;const o=Je(e,a);if(!ht(e,a)){if(n===!o)throw new Error("'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).");n=o,r=c}}if(n!==void 0)for(const[a,c]of bt)ne(e,a)&&Je(e,a)!==n&&(Ce(e,a,n),console.warn(`Though the "loose" option was set to "${!n}" in your @babel/preset-env config, it will not be used for ${c} since the "loose" mode option was set to "${n}" for ${r}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${c}", { "loose": ${n} }]
to the "plugins" section of your Babel config.`))}function ne(e,t){return!!(e.get(Ge)&t)}function Je(e,t){return!!(e.get(Ee)&t)}function Ce(e,t,s){s?e.set(Ee,e.get(Ee)|t):e.set(Ee,e.get(Ee)&~t),e.set(le,e.get(le)&~t)}function ht(e,t){return!!(e.get(le)&t)}function dn(e,t){let s=null,n=null,r=null,a=null,c=null;(0,gt.hasOwnDecorators)(e.node)&&(s=e.get("decorators.0"));for(const o of e.get("body.body"))!s&&(0,gt.hasOwnDecorators)(o.node)&&(s=o.get("decorators.0")),!n&&o.isClassProperty()&&(n=o),!r&&o.isClassPrivateProperty()&&(r=o),!a&&o.isClassPrivateMethod!=null&&o.isClassPrivateMethod()&&(a=o),!c&&o.isStaticBlock!=null&&o.isStaticBlock()&&(c=o);if(s&&r)throw r.buildCodeFrameError("Private fields in decorated classes are not supported yet.");if(s&&a)throw a.buildCodeFrameError("Private methods in decorated classes are not supported yet.");if(s&&!ne(t,te.decorators))throw e.buildCodeFrameError(`Decorators are not enabled.
If you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:
	["@babel/plugin-proposal-decorators", { "version": "legacy" }]
	["@babel/plugin-transform-class-properties", { "loose": true }]`);if(a&&!ne(t,te.privateMethods))throw a.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");if((n||r)&&!ne(t,te.fields)&&!ne(t,te.privateMethods))throw e.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");if(c&&!ne(t,te.staticBlocks))throw e.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");return!!(s||a||c||(n||r)&&ne(t,te.fields))}(function(e){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"FEATURES",{enumerable:!0,get:function(){return l.FEATURES}}),Object.defineProperty(e,"buildCheckInRHS",{enumerable:!0,get:function(){return a.buildCheckInRHS}}),e.createClassFeaturePlugin=f,Object.defineProperty(e,"enableFeature",{enumerable:!0,get:function(){return l.enableFeature}}),Object.defineProperty(e,"injectInitialization",{enumerable:!0,get:function(){return o.injectInitialization}});var t=oe(),s=Pt,n=Vt,r=Gt,a=de,c=ge,o=Ue,l=ue,p=We;const y="@babel/plugin-class-features/version";function f({name:b,feature:I,loose:F,manipulateOptions:i,api:u,inherits:v}){{var _;(_=u)!=null||(u={assumption:()=>{}})}const $=u.assumption("setPublicClassFields"),m=u.assumption("privateFieldsAsSymbols"),E=u.assumption("privateFieldsAsProperties"),N=u.assumption("constantSuper"),h=u.assumption("noDocumentAll");if(E&&m)throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');const C=E||m;if(F===!0){const x=[];$!==void 0&&x.push('"setPublicClassFields"'),E!==void 0&&x.push('"privateFieldsAsProperties"'),m!==void 0&&x.push('"privateFieldsAsSymbols"'),x.length!==0&&console.warn(`[${b}]: You are using the "loose: true" option and you are explicitly setting a value for the ${x.join(" and ")} assumption${x.length>1?"s":""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`)}return{name:b,manipulateOptions:i,inherits:v,pre(x){if((0,l.enableFeature)(x,I,F),typeof x.get(y)=="number"){x.set(y,"7.22.5");return}(!x.get(y)||r.lt(x.get(y),"7.22.5"))&&x.set(y,"7.22.5")},visitor:{Class(x,{file:O}){if(O.get(y)!=="7.22.5"||!(0,l.shouldTransform)(x,O))return;x.isClassDeclaration()&&(0,p.assertFieldTransformed)(x);const M=(0,l.isLoose)(O,I);let U;const ie=(0,c.hasDecorators)(x.node),g=[],j=[],w=[],S=new Set,P=x.get("body");for(const D of P.get("body")){if((D.isClassProperty()||D.isClassMethod())&&D.node.computed&&w.push(D),D.isPrivate()){const{name:K}=D.node.key.id,W=`get ${K}`,Z=`set ${K}`;if(D.isClassPrivateMethod()){if(D.node.kind==="get"){if(S.has(W)||S.has(K)&&!S.has(Z))throw D.buildCodeFrameError("Duplicate private field");S.add(W).add(K)}else if(D.node.kind==="set"){if(S.has(Z)||S.has(K)&&!S.has(W))throw D.buildCodeFrameError("Duplicate private field");S.add(Z).add(K)}}else{if(S.has(K)&&!S.has(W)&&!S.has(Z)||S.has(K)&&(S.has(W)||S.has(Z)))throw D.buildCodeFrameError("Duplicate private field");S.add(K)}}D.isClassMethod({kind:"constructor"})?U=D:(j.push(D),(D.isProperty()||D.isPrivate()||D.isStaticBlock!=null&&D.isStaticBlock())&&g.push(D))}if(!g.length&&!ie)return;const L=x.node.id;let B;!L||x.isClassExpression()?((0,s.default)(x),B=x.scope.generateUidIdentifier("class")):B=t.types.cloneNode(x.node.id);const q=(0,a.buildPrivateNamesMap)(g),V=(0,a.buildPrivateNamesNodes)(q,E??M,m??!1,O);(0,a.transformPrivateNamesUsage)(B,x,q,{privateFieldsAsProperties:C??M,noDocumentAll:h,innerBinding:L},O);let G,A,ee,re,se;ie?(A=re=G=[],{instanceNodes:ee,wrapClass:se}=(0,c.buildDecoratedClass)(B,x,j,O)):(G=(0,o.extractComputedKeys)(x,w,O),{staticNodes:A,pureStaticNodes:re,instanceNodes:ee,wrapClass:se}=(0,a.buildFieldsInitNodes)(B,x.node.superClass,g,q,O,$??M,C??M,N??M,L)),ee.length>0&&(0,o.injectInitialization)(x,U,ee,(D,K)=>{if(!ie)for(const W of g)t.types.isStaticBlock!=null&&t.types.isStaticBlock(W.node)||W.node.static||W.traverse(D,K)});const be=se(x);be.insertBefore([...V,...G]),A.length>0&&be.insertAfter(A),re.length>0&&be.find(D=>D.isStatement()||D.isDeclaration()).insertAfter(re)},ExportDefaultDeclaration(x,{file:O}){{if(O.get(y)!=="7.22.5")return;const M=x.get("declaration");M.isClassDeclaration()&&(0,c.hasDecorators)(M.node)&&(M.node.id?(0,n.default)(x):M.node.type="ClassExpression")}}}}}})(Nt);var tt={},Ne={};Object.defineProperty(Ne,"__esModule",{value:!0});Ne.default=mn;Ne.translateEnumValues=At;var ye=oe(),un=zt,pn=Le;const kt=new WeakMap,fn=ye.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `);function mn(e,t){const{node:s,parentPath:n}=e;if(s.declare){e.remove();return}const r=s.id.name,{fill:a,data:c,isPure:o}=hn(e,t,s.id);switch(n.type){case"BlockStatement":case"ExportNamedDeclaration":case"Program":{const p=t.isProgram(e.parent),y=l(n);let f=t.objectExpression([]);(y||p)&&(f=t.logicalExpression("||",t.cloneNode(a.ID),f));const b=fn(Object.assign({},a,{INIT:f}));o&&(0,pn.default)(b),y?(n.isExportDeclaration()?n:e).replaceWith(t.expressionStatement(t.assignmentExpression("=",t.cloneNode(s.id),b))):e.scope.registerDeclaration(e.replaceWith(t.variableDeclaration(p?"var":"let",[t.variableDeclarator(s.id,b)]))[0]),kt.set(e.scope.getBindingIdentifier(r),c);break}default:throw new Error(`Unexpected enum parent '${e.parent.type}`)}function l(p){return p.isExportDeclaration()?l(p.parentPath):p.getData(r)?!0:(p.setData(r,!0),!1)}}const yn=(0,ye.template)(`
  ENUM["NAME"] = VALUE;
`),gn=(0,ye.template)(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`),bn=(e,t)=>(e?yn:gn)(t);function hn(e,t,s){const{enumValues:n,data:r,isPure:a}=At(e,t),c=n.map(([o,l])=>bn(t.isStringLiteral(l),{ENUM:t.cloneNode(s),NAME:o,VALUE:l}));return{fill:{ID:t.cloneNode(s),ASSIGNMENTS:c},data:r,isPure:a}}function Mt(e,t){const{seen:s,path:n,t:r}=t,a=e.node.name;s.has(a)&&!e.scope.hasOwnBinding(a)&&(e.replaceWith(r.memberExpression(r.cloneNode(n.node.id),r.cloneNode(e.node))),e.skip())}const vn={ReferencedIdentifier:Mt};function At(e,t){const s=new Map;let n=-1,r,a=!0;const c=e.get("members").map(o=>{const l=o.node,p=t.isIdentifier(l.id)?l.id.name:l.id.value,y=o.get("initializer"),f=l.initializer;let b;if(f)n=Ft(y,s),n!==void 0?(s.set(p,n),typeof n=="number"?b=t.numericLiteral(n):(un(typeof n=="string"),b=t.stringLiteral(n))):(a&&(a=y.isPure()),y.isReferencedIdentifier()?Mt(y,{t,seen:s,path:e}):y.traverse(vn,{t,seen:s,path:e}),b=y.node,s.set(p,void 0));else if(typeof n=="number")n+=1,b=t.numericLiteral(n),s.set(p,n);else{if(typeof n=="string")throw e.buildCodeFrameError("Enum member must have initializer.");{const I=t.memberExpression(t.cloneNode(e.node.id),t.stringLiteral(r),!0);b=t.binaryExpression("+",t.numericLiteral(1),I),s.set(p,void 0)}}return r=p,[p,b]});return{isPure:a,data:s,enumValues:c}}function Ft(e,t,s=new Set){return n(e);function n(o){const l=o.node;switch(l.type){case"MemberExpression":return r(o,t,s);case"StringLiteral":return l.value;case"UnaryExpression":return a(o);case"BinaryExpression":return c(o);case"NumericLiteral":return l.value;case"ParenthesizedExpression":return n(o.get("expression"));case"Identifier":return r(o,t,s);case"TemplateLiteral":{if(l.quasis.length===1)return l.quasis[0].value.cooked;const p=o.get("expressions"),y=l.quasis;let f="";for(let b=0;b<y.length;b++)if(f+=y[b].value.cooked,b+1<y.length){const I=r(p[b],t,s);if(I===void 0)return;f+=I}return f}default:return}}function r(o,l,p){if(o.isMemberExpression()){const y=o.node,f=y.object,b=y.property;if(!ye.types.isIdentifier(f)||(y.computed?!ye.types.isStringLiteral(b):!ye.types.isIdentifier(b)))return;const I=o.scope.getBindingIdentifier(f.name),F=kt.get(I);return F?F.get(b.computed?b.value:b.name):void 0}else if(o.isIdentifier()){const y=o.node.name;let f=l?.get(y);if(f!==void 0)return f;if(p.has(o.node))return;const b=o.resolve();if(b)return p.add(o.node),f=Ft(b,void 0,p),l?.set(y,f),f}}function a(o){const l=n(o.get("argument"));if(l!==void 0)switch(o.node.operator){case"+":return l;case"-":return-l;case"~":return~l;default:return}}function c(o){const l=n(o.get("left"));if(l===void 0)return;const p=n(o.get("right"));if(p!==void 0)switch(o.node.operator){case"|":return l|p;case"&":return l&p;case">>":return l>>p;case">>>":return l>>>p;case"<<":return l<<p;case"^":return l^p;case"*":return l*p;case"/":return l/p;case"+":return l+p;case"-":return l-p;case"%":return l%p;case"**":return Math.pow(l,p);default:return}}}Object.defineProperty(tt,"__esModule",{value:!0});tt.default=xn;var En=Ne;function xn(e,t){const{name:s}=e.node.id,n=e.parentPath.isExportNamedDeclaration();let r=n;!r&&t.isProgram(e.parent)&&(r=e.parent.body.some(o=>t.isExportNamedDeclaration(o)&&o.exportKind!=="type"&&!o.source&&o.specifiers.some(l=>t.isExportSpecifier(l)&&l.exportKind!=="type"&&l.local.name===s)));const{enumValues:a}=(0,En.translateEnumValues)(e,t);if(r){const o=t.objectExpression(a.map(([l,p])=>t.objectProperty(t.isValidIdentifier(l)?t.identifier(l):t.stringLiteral(l),p)));e.scope.hasOwnBinding(s)?(n?e.parentPath:e).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"),t.identifier("assign")),[e.node.id,o]))):(e.replaceWith(t.variableDeclaration("var",[t.variableDeclarator(e.node.id,o)])),e.scope.registerDeclaration(e));return}const c=new Map(a);e.scope.path.traverse({Scope(o){o.scope.hasOwnBinding(s)&&o.skip()},MemberExpression(o){if(!t.isIdentifier(o.node.object,{name:s}))return;let l;if(o.node.computed)if(t.isStringLiteral(o.node.property))l=o.node.property.value;else return;else if(t.isIdentifier(o.node.property))l=o.node.property.name;else return;c.has(l)&&o.replaceWith(t.cloneNode(c.get(l)))}}),e.remove()}var st={};Object.defineProperty(st,"__esModule",{value:!0});st.default=Pn;var T=oe();function Pn(e,t){if(e.node.declare||e.node.id.type==="StringLiteral"){e.remove();return}if(!t)throw e.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const s=e.node.id.name,n=Qe(e,T.types.cloneNode(e.node,!0)),r=e.scope.hasOwnBinding(s);e.parent.type==="ExportNamedDeclaration"?r?e.parentPath.replaceWith(n):(e.parentPath.insertAfter(n),e.replaceWith(ke(s)),e.scope.registerDeclaration(e.parentPath)):r?e.replaceWith(n):e.scope.registerDeclaration(e.replaceWithMultiple([ke(s),n])[0])}function ke(e){return T.types.variableDeclaration("let",[T.types.variableDeclarator(T.types.identifier(e))])}function Xe(e,t){return T.types.memberExpression(T.types.identifier(e),T.types.identifier(t))}function Sn(e,t,s){if(e.kind!=="const")throw s.file.buildCodeFrameError(e,"Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const{declarations:n}=e;if(n.every(c=>T.types.isIdentifier(c.id))){for(const c of n)c.init=T.types.assignmentExpression("=",Xe(t,c.id.name),c.init);return[e]}const r=T.types.getBindingIdentifiers(e),a=[];for(const c in r)a.push(T.types.assignmentExpression("=",Xe(t,c),T.types.cloneNode(r[c])));return[e,T.types.expressionStatement(T.types.sequenceExpression(a))]}function vt(e,t){return e.hub.buildError(t,"Ambient modules cannot be nested in other modules or namespaces.",Error)}function Qe(e,t,s){const n=new Set,r=t.id;T.types.assertIdentifier(r);const a=e.scope.generateUid(r.name),c=T.types.isTSModuleBlock(t.body)?t.body.body:[T.types.exportNamedDeclaration(t.body)];for(let l=0;l<c.length;l++){const p=c[l];switch(p.type){case"TSModuleDeclaration":{if(!T.types.isIdentifier(p.id))throw vt(e,p);const y=Qe(e,p),f=p.id.name;n.has(f)?c[l]=y:(n.add(f),c.splice(l++,1,ke(f),y));continue}case"TSEnumDeclaration":case"FunctionDeclaration":case"ClassDeclaration":n.add(p.id.name);continue;case"VariableDeclaration":{for(const y in T.types.getBindingIdentifiers(p))n.add(y);continue}default:continue;case"ExportNamedDeclaration":}if(!("declare"in p.declaration&&p.declaration.declare))switch(p.declaration.type){case"TSEnumDeclaration":case"FunctionDeclaration":case"ClassDeclaration":{const y=p.declaration.id.name;n.add(y),c.splice(l++,1,p.declaration,T.types.expressionStatement(T.types.assignmentExpression("=",Xe(a,y),T.types.identifier(y))));break}case"VariableDeclaration":{const y=Sn(p.declaration,a,e.hub);c.splice(l,y.length,...y),l+=y.length-1;break}case"TSModuleDeclaration":{if(!T.types.isIdentifier(p.declaration.id))throw vt(e,p.declaration);const y=Qe(e,p.declaration,T.types.identifier(a)),f=p.declaration.id.name;n.has(f)?c[l]=y:(n.add(f),c.splice(l++,1,ke(f),y))}}}let o=T.types.objectExpression([]);if(s){const l=T.types.memberExpression(s,r);o=T.template.expression.ast`
      ${T.types.cloneNode(l)} ||
        (${T.types.cloneNode(l)} = ${o})
    `}return T.template.statement.ast`
    (function (${T.types.identifier(a)}) {
      ${c}
    })(${r} || (${T.types.cloneNode(r)} = ${o}));
  `}Object.defineProperty(Fe,"__esModule",{value:!0});Fe.default=void 0;var Nn=xe,In=Be,wn=Nt,_n=tt,Cn=Ne,$n=st;function Tn(e){switch(e.parent.type){case"TSTypeReference":case"TSExpressionWithTypeArguments":case"TSTypeQuery":return!0;case"TSQualifiedName":return e.parentPath.findParent(t=>t.type!=="TSQualifiedName").type!=="TSImportEqualsDeclaration";case"ExportSpecifier":return e.parent.exportKind==="type"||e.parentPath.parent.exportKind==="type";default:return!1}}const Me=new WeakMap,J=new WeakMap,Et=new WeakSet;function qe({scope:e},t){return e.hasBinding(t)?!1:Me.get(e).has(t)?!0:(console.warn(`The exported identifier "${t}" is not declared in Babel's scope tracker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${t}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`),!1)}function $e(e,t){Me.get(e).add(t)}function Te(e){const t=e.getBindingIdentifiers();for(const s of Object.keys(t)){const n=e.scope.getBinding(s);n&&n.identifier===t[s]&&n.scope.removeBinding(s)}e.opts.noScope=!0,e.remove(),e.opts.noScope=!1}function xt(e,t,s,n,r=""){if(t.file.get("@babel/plugin-transform-modules-*")!=="commonjs")throw e.buildCodeFrameError(`\`${s}\` is only supported when compiling modules to CommonJS.
Please consider using \`${n}\`${r}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`)}var On=(0,Nn.declare)((e,t)=>{const{types:s,template:n}=e;e.assertVersion(7);const r=/\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/,{allowNamespaces:a=!0,jsxPragma:c="React.createElement",jsxPragmaFrag:o="React.Fragment",onlyRemoveTypeImports:l=!1,optimizeConstEnums:p=!1}=t;var{allowDeclareFields:y=!1}=t;const f={field(i){const{node:u}=i;if(!y&&u.declare)throw i.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");if(u.declare){if(u.value)throw i.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");u.decorators||i.remove()}else if(u.definite){if(u.value)throw i.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");!y&&!u.decorators&&!s.isClassPrivateProperty(u)&&i.remove()}else(u.abstract||!y&&!u.value&&!u.decorators&&!s.isClassPrivateProperty(u))&&i.remove();u.accessibility&&(u.accessibility=null),u.abstract&&(u.abstract=null),u.readonly&&(u.readonly=null),u.optional&&(u.optional=null),u.typeAnnotation&&(u.typeAnnotation=null),u.definite&&(u.definite=null),u.declare&&(u.declare=null),u.override&&(u.override=null)},method({node:i}){i.accessibility&&(i.accessibility=null),i.abstract&&(i.abstract=null),i.optional&&(i.optional=null),i.override&&(i.override=null)},constructor(i,u){i.node.accessibility&&(i.node.accessibility=null);const v=[],{scope:_}=i;for(const $ of i.get("params")){const m=$.node;if(m.type==="TSParameterProperty"){const E=m.parameter;if(Et.has(E))continue;Et.add(E);let N;if(s.isIdentifier(E))N=E;else if(s.isAssignmentPattern(E)&&s.isIdentifier(E.left))N=E.left;else throw $.buildCodeFrameError("Parameter properties can not be destructuring patterns.");v.push(n.statement.ast`
          this.${s.cloneNode(N)} = ${s.cloneNode(N)}`),$.replaceWith($.get("parameter")),_.registerBinding("param",$)}}(0,wn.injectInitialization)(u,i,v)}};return{name:"transform-typescript",inherits:In.default,visitor:{Pattern:I,Identifier:I,RestElement:I,Program:{enter(i,u){const{file:v}=u;let _=null,$=null;const m=i.scope;if(Me.has(m)||Me.set(m,new Set),v.ast.comments)for(const h of v.ast.comments){const C=r.exec(h.value);C&&(C[1]?$=C[2]:_=C[2])}let E=_||c;E&&([E]=E.split("."));let N=$||o;N&&([N]=N.split("."));for(let h of i.get("body")){if(h.isImportDeclaration()){if(J.has(u.file.ast.program)||J.set(u.file.ast.program,!0),h.node.importKind==="type"){for(const M of h.node.specifiers)$e(m,M.local.name);h.remove();continue}const C=new Set,x=h.node.specifiers.length,O=()=>x>0&&x===C.size;for(const M of h.node.specifiers)if(M.type==="ImportSpecifier"&&M.importKind==="type"){$e(m,M.local.name);const U=h.scope.getBinding(M.local.name);U&&C.add(U.path)}if(l)J.set(i.node,!1);else{if(h.node.specifiers.length===0){J.set(i.node,!1);continue}for(const M of h.node.specifiers){const U=h.scope.getBinding(M.local.name);U&&!C.has(U.path)&&(F({binding:U,programPath:i,pragmaImportName:E,pragmaFragImportName:N})?C.add(U.path):J.set(i.node,!1))}}if(O()&&!l)h.remove();else for(const M of C)M.remove();continue}if(h.isExportDeclaration()&&(h=h.get("declaration")),h.isVariableDeclaration({declare:!0}))for(const C of Object.keys(h.getBindingIdentifiers()))$e(m,C);else(h.isTSTypeAliasDeclaration()||h.isTSDeclareFunction()&&h.get("id").isIdentifier()||h.isTSInterfaceDeclaration()||h.isClassDeclaration({declare:!0})||h.isTSEnumDeclaration({declare:!0})||h.isTSModuleDeclaration({declare:!0})&&h.get("id").isIdentifier())&&$e(m,h.node.id.name)}},exit(i){i.node.sourceType==="module"&&J.get(i.node)&&i.pushContainer("body",s.exportNamedDeclaration())}},ExportNamedDeclaration(i,u){if(J.has(u.file.ast.program)||J.set(u.file.ast.program,!0),i.node.exportKind==="type"){i.remove();return}if(i.node.source&&i.node.specifiers.length>0&&i.node.specifiers.every(v=>v.type==="ExportSpecifier"&&v.exportKind==="type")){i.remove();return}if(!i.node.source&&i.node.specifiers.length>0&&i.node.specifiers.every(v=>s.isExportSpecifier(v)&&qe(i,v.local.name))){i.remove();return}J.set(u.file.ast.program,!1)},ExportAllDeclaration(i){i.node.exportKind==="type"&&i.remove()},ExportSpecifier(i){(!i.parent.source&&qe(i,i.node.local.name)||i.node.exportKind==="type")&&i.remove()},ExportDefaultDeclaration(i,u){if(J.has(u.file.ast.program)||J.set(u.file.ast.program,!0),s.isIdentifier(i.node.declaration)&&qe(i,i.node.declaration.name)){i.remove();return}J.set(u.file.ast.program,!1)},TSDeclareFunction(i){Te(i)},TSDeclareMethod(i){Te(i)},VariableDeclaration(i){i.node.declare&&Te(i)},VariableDeclarator({node:i}){i.definite&&(i.definite=null)},TSIndexSignature(i){i.remove()},ClassDeclaration(i){const{node:u}=i;u.declare&&Te(i)},Class(i){const{node:u}=i;u.typeParameters&&(u.typeParameters=null),u.superTypeParameters&&(u.superTypeParameters=null),u.implements&&(u.implements=null),u.abstract&&(u.abstract=null),i.get("body.body").forEach(v=>{v.isClassMethod()||v.isClassPrivateMethod()?v.node.kind==="constructor"?f.constructor(v,i):f.method(v):(v.isClassProperty()||v.isClassPrivateProperty()||v.isClassAccessorProperty())&&f.field(v)})},Function(i){const{node:u}=i;u.typeParameters&&(u.typeParameters=null),u.returnType&&(u.returnType=null);const v=u.params;v.length>0&&s.isIdentifier(v[0],{name:"this"})&&v.shift()},TSModuleDeclaration(i){(0,$n.default)(i,a)},TSInterfaceDeclaration(i){i.remove()},TSTypeAliasDeclaration(i){i.remove()},TSEnumDeclaration(i){p&&i.node.const?(0,_n.default)(i,s):(0,Cn.default)(i,s)},TSImportEqualsDeclaration(i,u){const{id:v,moduleReference:_}=i.node;let $,m;s.isTSExternalModuleReference(_)?(xt(i,u,`import ${v.name} = require(...);`,`import ${v.name} from '...';`," alongside Typescript's --allowSyntheticDefaultImports option"),$=s.callExpression(s.identifier("require"),[_.expression]),m="const"):($=b(_),m="var"),i.replaceWith(s.variableDeclaration(m,[s.variableDeclarator(v,$)])),i.scope.registerDeclaration(i)},TSExportAssignment(i,u){xt(i,u,"export = <value>;","export default <value>;"),i.replaceWith(n.statement.ast`module.exports = ${i.node.expression}`)},TSTypeAssertion(i){i.replaceWith(i.node.expression)},[`TSAsExpression${s.tsSatisfiesExpression?"|TSSatisfiesExpression":""}`](i){let{node:u}=i;do u=u.expression;while(s.isTSAsExpression(u)||s.isTSSatisfiesExpression!=null&&s.isTSSatisfiesExpression(u));i.replaceWith(u)},[e.types.tsInstantiationExpression?"TSNonNullExpression|TSInstantiationExpression":"TSNonNullExpression"](i){i.replaceWith(i.node.expression)},CallExpression(i){i.node.typeParameters=null},OptionalCallExpression(i){i.node.typeParameters=null},NewExpression(i){i.node.typeParameters=null},JSXOpeningElement(i){i.node.typeParameters=null},TaggedTemplateExpression(i){i.node.typeParameters=null}}};function b(i){return s.isTSQualifiedName(i)?s.memberExpression(b(i.left),i.right):i}function I({node:i}){i.typeAnnotation&&(i.typeAnnotation=null),s.isIdentifier(i)&&i.optional&&(i.optional=null)}function F({binding:i,programPath:u,pragmaImportName:v,pragmaFragImportName:_}){for(const m of i.referencePaths)if(!Tn(m))return!1;if(i.identifier.name!==v&&i.identifier.name!==_)return!0;let $=!1;return u.traverse({"JSXElement|JSXFragment"(m){$=!0,m.stop()}}),!$}});Fe.default=On;var nt={};Object.defineProperty(nt,"__esModule",{value:!0});nt.default=void 0;var jn=xe,Dn=(0,jn.declare)(e=>(e.assertVersion(7),{name:"syntax-jsx",manipulateOptions(t,s){s.plugins.some(n=>(Array.isArray(n)?n[0]:n)==="typescript")||s.plugins.push("jsx")}}));nt.default=Dn;var He={},it={};Object.defineProperty(it,"__esModule",{value:!0});it.transformDynamicImport=An;var Bt=oe(),kn=St;const Rt=e=>Bt.template.expression.ast`require(${e})`,Mn=(e,t)=>Bt.types.callExpression(t.addHelper("interopRequireWildcard"),[Rt(e)]);function An(e,t,s){const n=t?Rt:Mn;e.replaceWith((0,kn.buildDynamicImport)(e.node,!0,!1,r=>n(r,s)))}Object.defineProperty(He,"__esModule",{value:!0});He.default=void 0;var Fn=xe,ae=St,Bn=qt,X=oe(),Rn=it,Ln=(0,Fn.declare)((e,t)=>{var s,n,r;e.assertVersion(7);const{strictNamespace:a=!1,mjsStrictNamespace:c=a,allowTopLevelThis:o,strict:l,strictMode:p,noInterop:y,importInterop:f,lazy:b=!1,allowCommonJSExports:I=!0,loose:F=!1}=t,i=(s=e.assumption("constantReexports"))!=null?s:F,u=(n=e.assumption("enumerableModuleMeta"))!=null?n:F,v=(r=e.assumption("noIncompleteNsImportDetection"))!=null?r:!1;if(typeof b!="boolean"&&typeof b!="function"&&(!Array.isArray(b)||!b.every(m=>typeof m=="string")))throw new Error(".lazy must be a boolean, array of strings, or a function");if(typeof a!="boolean")throw new Error(".strictNamespace must be a boolean, or undefined");if(typeof c!="boolean")throw new Error(".mjsStrictNamespace must be a boolean, or undefined");const _=m=>X.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${m}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `,$={ReferencedIdentifier(m){const E=m.node.name;if(E!=="module"&&E!=="exports")return;const N=m.scope.getBinding(E);this.scope.getBinding(E)!==N||m.parentPath.isObjectProperty({value:m.node})&&m.parentPath.parentPath.isObjectPattern()||m.parentPath.isAssignmentExpression({left:m.node})||m.isAssignmentExpression({left:m.node})||m.replaceWith(_(E))},UpdateExpression(m){const E=m.get("argument");if(!E.isIdentifier())return;const N=E.node.name;if(N!=="module"&&N!=="exports")return;const h=m.scope.getBinding(N);this.scope.getBinding(N)===h&&m.replaceWith(X.types.assignmentExpression(m.node.operator[0]+"=",E.node,_(N)))},AssignmentExpression(m){const E=m.get("left");if(E.isIdentifier()){const N=E.node.name;if(N!=="module"&&N!=="exports")return;const h=m.scope.getBinding(N);if(this.scope.getBinding(N)!==h)return;const x=m.get("right");x.replaceWith(X.types.sequenceExpression([x.node,_(N)]))}else if(E.isPattern()){const N=E.getOuterBindingIdentifiers(),h=Object.keys(N).filter(C=>C!=="module"&&C!=="exports"?!1:this.scope.getBinding(C)===m.scope.getBinding(C))[0];if(h){const C=m.get("right");C.replaceWith(X.types.sequenceExpression([C.node,_(h)]))}}}};return{name:"transform-modules-commonjs",pre(){this.file.set("@babel/plugin-transform-modules-*","commonjs")},visitor:{CallExpression(m){if(!this.file.has("@babel/plugin-proposal-dynamic-import")||!X.types.isImport(m.node.callee))return;let{scope:E}=m;do E.rename("require");while(E=E.parent);(0,Rn.transformDynamicImport)(m,y,this.file)},Program:{exit(m,E){if(!(0,ae.isModule)(m))return;m.scope.rename("exports"),m.scope.rename("module"),m.scope.rename("require"),m.scope.rename("__filename"),m.scope.rename("__dirname"),I||((0,Bn.default)(m,new Set(["module","exports"]),!1),m.traverse($,{scope:m.scope}));let N=(0,ae.getModuleName)(this.file.opts,t);N&&(N=X.types.stringLiteral(N));const{meta:h,headers:C}=(0,ae.rewriteModuleStatementsAndPrepareHeader)(m,{exportName:"exports",constantReexports:i,enumerableModuleMeta:u,strict:l,strictMode:p,allowTopLevelThis:o,noInterop:y,importInterop:f,lazy:b,esNamespaceOnly:typeof E.filename=="string"&&/\.mjs$/.test(E.filename)?c:a,noIncompleteNsImportDetection:v,filename:this.file.opts.filename});for(const[x,O]of h.source){const M=X.types.callExpression(X.types.identifier("require"),[X.types.stringLiteral(x)]);let U;if((0,ae.isSideEffectImport)(O)){if(O.lazy)throw new Error("Assertion failure");U=X.types.expressionStatement(M)}else{if(O.lazy&&!O.referenced)continue;const ie=(0,ae.wrapInterop)(m,M,O.interop)||M;O.lazy?U=X.template.statement.ast`
                  function ${O.name}() {
                    const data = ${ie};
                    ${O.name} = function(){ return data; };
                    return data;
                  }
                `:U=X.template.statement.ast`
                  var ${O.name} = ${ie};
                `}U.loc=O.loc,C.push(U),C.push(...(0,ae.buildNamespaceInitStatements)(h,O,i))}(0,ae.ensureStatementsHoisted)(C),m.unshiftContainer("body",C),m.get("body").forEach(x=>{C.indexOf(x.node)!==-1&&x.isVariableDeclaration()&&x.scope.registerDeclaration(x)})}}}}});He.default=Ln;(function(e){Object.defineProperty(e,"__esModule",{value:!0});var t=xe,s=Fe,n=He,r=Kt;function a(f){return f&&typeof f=="object"&&"default"in f?f:{default:f}}var c=a(s),o=a(n);const l=new r.OptionValidator("@babel/preset-typescript");function p(f={}){let{allowNamespaces:b=!0,jsxPragma:I,onlyRemoveTypeImports:F}=f;const i={ignoreExtensions:"ignoreExtensions",allowNamespaces:"allowNamespaces",disallowAmbiguousJSXLike:"disallowAmbiguousJSXLike",jsxPragma:"jsxPragma",jsxPragmaFrag:"jsxPragmaFrag",onlyRemoveTypeImports:"onlyRemoveTypeImports",optimizeConstEnums:"optimizeConstEnums",allExtensions:"allExtensions",isTSX:"isTSX"},u=l.validateStringOption(i.jsxPragmaFrag,f.jsxPragmaFrag,"React.Fragment");{var v=l.validateBooleanOption(i.allExtensions,f.allExtensions,!1),_=l.validateBooleanOption(i.isTSX,f.isTSX,!1);_&&l.invariant(v,"isTSX:true requires allExtensions:true")}const $=l.validateBooleanOption(i.ignoreExtensions,f.ignoreExtensions,!1),m=l.validateBooleanOption(i.disallowAmbiguousJSXLike,f.disallowAmbiguousJSXLike,!1);m&&l.invariant(v,"disallowAmbiguousJSXLike:true requires allExtensions:true");const E=l.validateBooleanOption(i.optimizeConstEnums,f.optimizeConstEnums,!1),N={ignoreExtensions:$,allowNamespaces:b,disallowAmbiguousJSXLike:m,jsxPragma:I,jsxPragmaFrag:u,onlyRemoveTypeImports:F,optimizeConstEnums:E};return N.allExtensions=v,N.isTSX=_,N}var y=t.declarePreset((f,b)=>{f.assertVersion(7);const{allExtensions:I,ignoreExtensions:F,allowNamespaces:i,disallowAmbiguousJSXLike:u,isTSX:v,jsxPragma:_,jsxPragmaFrag:$,onlyRemoveTypeImports:m,optimizeConstEnums:E}=p(b),N=x=>({allowDeclareFields:b.allowDeclareFields,allowNamespaces:i,disallowAmbiguousJSXLike:x,jsxPragma:_,jsxPragmaFrag:$,onlyRemoveTypeImports:m,optimizeConstEnums:E}),h=(x,O)=>[[c.default,Object.assign({isTSX:x},N(O))]];return{overrides:I||F?[{plugins:h(v,u)}]:[{test:/\.ts$/,plugins:h(!1,!1)},{test:/\.mts$/,sourceType:"module",plugins:h(!1,!0)},{test:/\.cts$/,sourceType:"unambiguous",plugins:[[o.default,{allowTopLevelThis:!0}],[c.default,N(!0)]]},{test:/\.tsx$/,plugins:h(!0,!1)}]}});e.default=y})(Ze);const Wn=Wt(Ze),qn=Jt({__proto__:null,default:Wn},[Ze]);export{qn as i};
